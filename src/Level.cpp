#include "../include/Level.h"
#include "../include/Tile.h"
#include "../include/Floor.h"
#include "../include/Wall.h"
#include "../include/Portal.h"
#include "../include/Character.h"
#include <cassert>

Level::Level() {
    // Beispiel Level
    const std::vector<std::string> l = {
        "##########",
        "#O.......#",
        "#........#",
        "#........#",
        "#........#",
        "#........#",
        "##########",
        "#O.......#",
        "#........#",
        "##########"
    };
    height = static_cast<int>(l.size());
    width = static_cast<int>(l.front().size());
    grid.assign(height, std::vector<Tile*>(width, nullptr));

    // tiles erzeugen
    std::vector<Portal*> portals;
    for (int r = 0; r < height; ++r) {
        assert((int)l[r].size() == width);
        for (int c = 0; c < width; ++c) {
            char ch = l[r][c];
            Tile* t = nullptr;
            switch (ch) {
                case '#': t = new Wall(r, c); break;
                case '.': t = new Floor(r, c); break;
                case 'O': {
                    auto* p = new Portal(r, c);
                    portals.push_back(p);
                    t = p; break;
                }
                default:  t = new Floor(r, c); break;
            }
            grid[r][c] = t;
        }
    }

    // portale paaren
    for (size_t i = 0; i < portals.size(); i+= 2) {
        portals[i]->setDestination(portals[i+1]);
        portals[i+1]->setDestination(portals[i]);
    }

    // eine Figur an Startposition setzen
    Character* hero = new Character("X");
    characters.push_back(hero);
    placeCharacter(hero, 2, 2); // Irgendwo bei (2,2)
}

Level::~Level() {
    for (auto& row : grid) {
        for (Tile* t : row) delete t;
    }
    for (Character* c : characters) delete c;
}

int Level::getHeight() const { return height; }
int Level::getWidth() const { return width; }

Tile* Level::getTile(int r, int c) {
    if (r < 0 || c < 0 || r >= height || c >= width) return nullptr;
    return grid[r][c];
}

const Tile *Level::getTile(int r, int c) const {
    if (r < 0 || c < 0 || r >= height || c >= width) return nullptr;
    return grid[r][c];
}

void Level::placeCharacter(Character* c, int r, int col) {
    Tile* t = getTile(r, col);
    if (!t) return;

    // alte kachel rÃ¤umen
    if (c->getTile()) c->getTile()->setCharacter(nullptr);

    // neue Kachel setzen
    t->setCharacter(c);
    c->setTile(t);
}

Character* Level::getPlayer() const { return characters.empty() ? nullptr : characters.front(); }
const std::vector<Character *> &Level::getCharacters() const { return characters; }


